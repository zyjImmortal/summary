#### 面向对象编程

#### 进程

#### 线程

#### 协程

#### socket编程

#### lambda

#### linux 命令

- 杀死进程
- 查看端口占用

#### cookie 和session

#### 算法



#### 数据结构

* 元组列表range

* 字符串拆分，单引号、双引号、三引号

* 可变参数

* pass语句

* re模块中search和match的区别

* fastcgi和wsgi的区别

  wsgi是一种python的web应用程序和服务之间的通讯协议，fastcgi是cgi的一种进化版本，cgi叫做通用网关接口，是一种供服务器和应用程序之间通讯的工具，是由编程语言实现的，fastcgi是cgi的进行版本，提供了进程管理，当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi

  *区别* FastCGI是服务器和应用程序解释器通讯的协议

* 文件操作

  

* 内存管理

  * 内存管理，即如何分配内存，如何追踪，如何回收

  * 动态类型

    对变量内存地址的分配是在运行时自动判断变量类型并对变量进行赋值

  * 内存池机制

    * 内存的分配方式
      * C中的malloc，free等内存分配和释放函数进行操作
      * Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存
    * 针对小块内存的频繁申请和释放，python引入了内存池机制对此进行管理，对于在内存池登记的内存，回收时不是直接在操作系统释放掉，而是再返回给内存池以便复用
    * 如果请求分配的内存在1~256字节之间就使用自己的内存管理系统,否则直接使用 malloc

  * 引用计数

    * python为每一个对象维护了一个指向该对对象的引用的计数，来保持追踪内存中的对象

    * 引用计数增加的情况

      1.对象被创建：x=4

      2.另外的别人被创建：y=x

      3.被作为参数传递给函数：foo(x)

      4.作为容器对象的一个元素：a=[1,x,'33']

      5.在对象中引用另一个对象

    * 引用计数减少的情况

      1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1。

      2.对象的别名被显式的销毁：del x ；或者del y

      3.对象的一个别名被赋值给其他对象：x=789

      4.对象从一个窗口对象中移除：myList.remove(x)

      5.窗口对象本身被销毁：del myList，或者窗口对象本身离开了作用域

      

  * 垃圾回收

    * 引用计数为0回收

    python为每一个对象维护了一个指向该对对象的引用的计数，系统会自动维护这些标签，并定时扫描，当某标签的引用计数变为0的时候，该对就会被回收

    * 分代回收

    Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。我们也可以通过gc模块的set_threshold()来设置扫描频率。

    Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。

    * 循环引用回收

      当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。(从而导致内存泄露)。解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们

      

* items和iteriterms的区别

  items返回一个dict_items对象，是一个可迭代对象，用元祖的形式返回key，value，可以用list、tuple作用于dict_item,也用iter(dict_items)返回一个迭代器，用next()方法获取元素，也可用for循环操作

  ``````python
  a = dict(vv='s',gg='ff')
  a.items() # 返回下面的内容
  dict_items([('vv', 's'), ('gg', 'ff')])，
  ``````

  iteriterms在python3中去除掉了