# BM算法的核心思想

前面的文章提到过BF算法和RK算法，这两种算法在进行匹配时，模式字符串和主串从开头字符一一比较，如果发现不匹配的，模式字符串就往后移动一位，而BM算法在遇到某个字符不匹配的时候，是把模式字符串直接移动到这个字符的后面，这样一次性可以多滑动几位，从而提高匹配效率。

# 具体算法原理

BM 算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good suffix shift）

## 坏字符规则

前面在进行字符比较的时候，都是按照模式字符串的索引从小到大进行比较，而BM算法是从大到小进行匹配。在匹配的过程中发现某个字符不一样，主串中的这个字符称作为**坏字符**

然后拿着这个坏字符在模式串中查找，如果不存在这个坏字符，那直接将模式字符串移动到这个坏字符的后面，但是如果发现存在这个坏字符，就滑动模式字符串，将这两字符位置对应上，如果在模式字符串中出现多个，就选择最靠后的那个，因为这样不会让模式串滑动过多，导致错失匹配，然后再从后往前开始匹配，重复上面的规则。

## 好后缀规则

在进行字符串从后往前开始匹配的时候，有写字符可能是匹配的，但是再往前匹配的时候，就不匹配了出现了坏字符。这个时候就可以利用好后缀规则对匹配的字符进行处理。

我们将匹配的字符合并成一个字符串，然后用这个字串在模式字符串中查找，如果查找到就将模式串移动到与子串匹配的位置，如果找不到就直接滑动到子串的后面。