# 为什么springboot有这么多复杂的概念





# 开闭原则OCP(open-closed-principle)

可维护代码的基础，对扩展开发对修改封闭

新增业务模块/类代替原来的类，这样的会比修改原来的代码引起bug的可能性更小

类、模块、系统都可以应用开闭原则，它是一种思想，，其他好多原则几乎也都是为了开闭原则服务



# 面向抽象编程

interface abstract

多态

不能依赖具体的类，而是要依赖抽象-interface或者abstract，目的是让代码具有可维护性，

面向抽象 - > 开闭原则 ->让代码实现可维护性



实例化一个对象，使用这个对象做一些事情

单纯的interface可以统一方法的调用，但是不能统一对象的实例化，

统一方法调用和统一对象的实例化，才能实现开闭原则



只有一段代码中没有new的出现，才能保持代码的相对稳定，才能逐步实现OCP开闭原则

如果一段代码想要保持稳定，就不应该负责对象的实例化

对象的实例化是不能消除的

把实例化的过程转移到其他代码片段里



工厂模式：

mian方法时相对稳定，另外的一个类里确实不稳定的，每一次新增都要变动，

代码中总是存在不稳定的，隔离不稳定，保证其他代码是稳定的

稳定是相对的

需要把变化的地方封装隔离起来



变化的地方是用户的输入或者是使用方的多种多样，是导致程序不稳定的主要原因，



因为是面向对象编程，所以当用户有有着不同的输入的时候，就需要创建不同的对象，





1、翻身的性能比较低，这里的实现方式是每次获取对象都要反射一次，性能损耗较大，spring的处理方式是：对反射创建过得对象进行缓存

2、DI



反射之前的代码还是没有用到IOC和DI，即使用到了工厂模式、反射，但是依然是正向思维，也就是说，写代码的思路依然是需要什么就调用什么类下面的什么方法。使用起来还是不方便的，还是要引入factory，

省略factory的引入





为什么有了工厂模式还要有IOC呢





DIP 依赖倒置

高层模块不应该依赖底层模块，两者多应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象

依赖注入的方式

属性注入

构造注入









