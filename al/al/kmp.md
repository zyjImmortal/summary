kmp算法也是一种字符串匹配算法，但是他和BM算法不同的是，从前往后开始匹配。共同点是都是想找出滑动最大位数的规律。

假设现在有两个字符串，一个是abaabaabbabaaabaabbabaab,起个名叫m，另一个abaabbabaab叫p，

![image-20200114145650537](/Users/zhouyajun/Library/Application Support/typora-user-images/image-20200114145650537.png)

两个字符串从头开始匹配的，匹配到第六个字符的时候出现不匹配的情况，这个时候把主串的第六位字符叫做坏字符，前面匹配到的叫做好前缀，这两个称呼都是针对主串的。当出现不匹配的坏字符的时候，模式串滑动多少位，能够更快的匹配完？

KMP算法就是在视图寻找一种规律，在模式传和主串匹配的过程中，当遇到坏字符后，能否找到一种规律，将模式串一次性滑动很多位，而且匹配的字符尽可能的不再匹配。

观察主串的好前缀其实也是模式串的前缀子串，我们只要找出公共的子串，公共子串同时也是后缀子串，就可以确定滑动的位数，以上面的两个字符串为例，最长的公共子串是ab，长度为2，坏字符的索引是5，将模式串滑动到公共子串的位置所需滑动的位数5-2=3，如下图：

![image-20200114151444427](/Users/zhouyajun/Library/Application Support/typora-user-images/image-20200114151444427.png)

然后坏字符的位置再重新开始匹配，公共子串里的字符就不需要再匹配了。

假设坏字符对应主串的位置是i，在模式串的位置是j，最长公共子串，就是模式串p[0]到p[j]之间子串的，前缀和后缀的最长公共子串。那我们是不是可以对每个位置的模式串子串求最长公共子串，然后把它存到数组里，当主串和模式串匹配到坏字符的时候，直接从数组中取出最长公共子串，然后就可以得出滑动的位数了。

那我们来看下一下这个数组是如何构造的以及都有什么特征。

数组的值存储的是，最长可匹配前缀子串的结尾字符的下标，这里我们前缀子串和后缀子串去最长数组的下标是每个前缀子串的下标

模式字符串 a b a b a c d

| 模式串前缀  | 前缀子串结尾字符下标 | 最长可匹配前缀子串结尾字符下标 | next值       |
| ----------- | -------------------- | :----------------------------: | ------------ |
| a           | 0                    |         -1(表示不存在)         | next[0] = -1 |
| a b         | 1                    |               -1               | next[1] = -1 |
| a b a       | 2                    |              *0*               | next[2] = 0  |
| a b a b     | 3                    |               1                | next[3] = 1  |
| a b a b a   | 4                    |               2                | next[4] = 2  |
| a b a b a c | 5                    |               -1               | next[5] = -1 |

