### 并发编程的3个基本概念

#### 原子性

即一个操作或者或者多个操作，要么全部执行并且执行过程不会被任何因素打断，要么就不执行。

原子性是拒绝多线程操作的，不论是单核还是多核，具有原子性的量，同一时刻只能有一个线程来怼他进行操作。

也就是说，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。

java中的原子操作：

- 基本类型的读取和赋值操作，且赋值必须是数字赋值给变量，变量之间的相互赋值不算原子操作
- 所有引用的赋值操作
- java.concurrent.Atomic.* 包中所有类的一切操作

#### 可见性

指的是当多线程访问同一个变量的时候，一个线程修改了这个变量的值，其他线程能够立即看的到修改之后的内容

在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性

#### 有序性

定义：即程序执行的顺序按照代码的先后顺序执行。

Java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。

在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。